//
// auto-generated by ops.py
//

int xdim0_prolong_check;


//user function



void prolong_check_c_wrapper(
  double * restrict val_p,
  int * restrict idx,
  int * restrict err_g,
  const int * restrict sizex,
  const int * restrict sizey,
  int arg_idx0, int arg_idx1,
  int x_size, int y_size) {
  int err_0 = err_g[0];
  #pragma omp parallel for reduction(max:err_0)
  for ( int n_y=0; n_y<y_size; n_y++ ){
    for ( int n_x=0; n_x<x_size; n_x++ ){
      int err[1];
      err[0] = err_g[0];
      int idx[] = {arg_idx0+n_x, arg_idx1+n_y};
      const ptr_double val = { val_p + n_x*1 + n_y * xdim0_prolong_check*1, xdim0_prolong_check};
      
  int lerr = 0;
  lerr |= (OPS_ACC(val, 0,0) != idx[0]/4 + (idx[1]/4)*(*sizex/4));


  int xm = (idx[0]-1)<0 ? *sizex-1 : idx[0]-1;
  int xp = (idx[0]+1)>=*sizex ? 0 : idx[0]+1;
  int ym = (idx[1]-1)<0 ? *sizey-1 : idx[1]-1;
  int yp = (idx[1]+1)>=*sizey ? 0 : idx[1]+1;
  lerr |= (OPS_ACC(val, 1,0) != xp/4 + (idx[1]/4)*(*sizex/4));


  lerr |= (OPS_ACC(val, -1,0) != xm/4 + (idx[1]/4)*(*sizex/4));


  lerr |= (OPS_ACC(val, 0,1) != idx[0]/4 + (yp/4)*(*sizex/4));


  lerr |= (OPS_ACC(val, 0,-1) != idx[0]/4 + (ym/4)*(*sizex/4));



  if (lerr != 0) *err = 1;
  else *err = 0;


      err_0 = MAX(err_0,err[0]);
    }
  }
  err_g[0] = err_0;
}
